/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("three"));
	else if(typeof define === 'function' && define.amd)
		define(["three"], factory);
	else if(typeof exports === 'object')
		exports["Nexus3D"] = factory(require("three"));
	else
		root["Nexus3D"] = factory(root["THREE"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Binary.js":
/*!***********************!*\
  !*** ./src/Binary.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFloat32: () => (/* binding */ getFloat32),\n/* harmony export */   getUint16: () => (/* binding */ getUint16),\n/* harmony export */   getUint32: () => (/* binding */ getUint32),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   matInv: () => (/* binding */ matInv),\n/* harmony export */   matMul: () => (/* binding */ matMul),\n/* harmony export */   vecMul: () => (/* binding */ vecMul)\n/* harmony export */ });\n/* UTILITIES */\n    \nfunction getUint64(view) {\n    var s = 0;\n    var lo = view.getUint32(view.offset, true);\n    var hi = view.getUint32(view.offset + 4, true);\n    view.offset += 8;\n    return ((hi * (1 << 32)) + lo);\n}\n\nfunction getUint32(view) {\n    var s = view.getUint32(view.offset, true);\n    view.offset += 4;\n    return s;\n}\n\nfunction getUint16(view) {\n    var s = view.getUint16(view.offset, true);\n    view.offset += 2;\n    return s;\n}\n\nfunction getFloat32(view) {\n    var s = view.getFloat32(view.offset, true);\n    view.offset += 4;\n    return s;\n}\n\n/* MATRIX STUFF */\n\nfunction vecMul(m, v, r) {\n    var w = m[3]*v[0] + m[7]*v[1] + m[11]*v[2] + m[15];\n\n    r[0] = (m[0]*v[0]  + m[4]*v[1]  + m[8 ]*v[2] + m[12 ])/w;\n    r[1] = (m[1]*v[0]  + m[5]*v[1]  + m[9 ]*v[2] + m[13 ])/w;\n    r[2] = (m[2]*v[0]  + m[6]*v[1]  + m[10]*v[2] + m[14])/w;\n}\n\n\nfunction matMul(a, b, r) {\n    r[ 0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];\n    r[ 1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];\n    r[ 2] = a[2]*b[0] + a[6]*b[1] + a[10]*b[2] + a[14]*b[3];\n    r[ 3] = a[3]*b[0] + a[7]*b[1] + a[11]*b[2] + a[15]*b[3];\n\n    r[ 4] = a[0]*b[4] + a[4]*b[5] + a[8]*b[6] + a[12]*b[7];\n    r[ 5] = a[1]*b[4] + a[5]*b[5] + a[9]*b[6] + a[13]*b[7];\n    r[ 6] = a[2]*b[4] + a[6]*b[5] + a[10]*b[6] + a[14]*b[7];\n    r[ 7] = a[3]*b[4] + a[7]*b[5] + a[11]*b[6] + a[15]*b[7];\n\n    r[ 8] = a[0]*b[8] + a[4]*b[9] + a[8]*b[10] + a[12]*b[11];\n    r[ 9] = a[1]*b[8] + a[5]*b[9] + a[9]*b[10] + a[13]*b[11];\n    r[10] = a[2]*b[8] + a[6]*b[9] + a[10]*b[10] + a[14]*b[11];\n    r[11] = a[3]*b[8] + a[7]*b[9] + a[11]*b[10] + a[15]*b[11];\n\n    r[12] = a[0]*b[12] + a[4]*b[13] + a[8]*b[14] + a[12]*b[15];\n    r[13] = a[1]*b[12] + a[5]*b[13] + a[9]*b[14] + a[13]*b[15];\n    r[14] = a[2]*b[12] + a[6]*b[13] + a[10]*b[14] + a[14]*b[15];\n    r[15] = a[3]*b[12] + a[7]*b[13] + a[11]*b[14] + a[15]*b[15];\n}\n\nfunction matInv(m, t) {\n    var s = 1.0/(\n        m[12]* m[9]*m[6]*m[3]-m[8]*m[13]*m[6]*m[3]-m[12]*m[5]*m[10]*m[3]+m[4]*m[13]*m[10]*m[3]+\n        m[8]*m[5]*m[14]*m[3]-m[4]*m[9]*m[14]*m[3]-m[12]*m[9]*m[2]*m[7]+m[8]*m[13]*m[2]*m[7]+\n        m[12]*m[1]*m[10]*m[7]-m[0]*m[13]*m[10]*m[7]-m[8]*m[1]*m[14]*m[7]+m[0]*m[9]*m[14]*m[7]+\n        m[12]*m[5]*m[2]*m[11]-m[4]*m[13]*m[2]*m[11]-m[12]*m[1]*m[6]*m[11]+m[0]*m[13]*m[6]*m[11]+\n        m[4]*m[1]*m[14]*m[11]-m[0]*m[5]*m[14]*m[11]-m[8]*m[5]*m[2]*m[15]+m[4]*m[9]*m[2]*m[15]+\n        m[8]*m[1]*m[6]*m[15]-m[0]*m[9]*m[6]*m[15]-m[4]*m[1]*m[10]*m[15]+m[0]*m[5]*m[10]*m[15]\n    );\n\n    t[ 0] = (m[9]*m[14]*m[7]-m[13]*m[10]*m[7]+m[13]*m[6]*m[11]-m[5]*m[14]*m[11]-m[9]*m[6]*m[15]+m[5]*m[10]*m[15])*s;\n    t[ 1] = (m[13]*m[10]*m[3]-m[9]*m[14]*m[3]-m[13]*m[2]*m[11]+m[1]*m[14]*m[11]+m[9]*m[2]*m[15]-m[1]*m[10]*m[15])*s;\n    t[ 2] = (m[5]*m[14]*m[3]-m[13]*m[6]*m[3]+m[13]*m[2]*m[7]-m[1]*m[14]*m[7]-m[5]*m[2]*m[15]+m[1]*m[6]*m[15])*s;\n    t[ 3] = (m[9]*m[6]*m[3]-m[5]*m[10]*m[3]-m[9]*m[2]*m[7]+m[1]*m[10]*m[7]+m[5]*m[2]*m[11]-m[1]*m[6]*m[11])*s;\n\n    t[ 4] = (m[12]*m[10]*m[7]-m[8]*m[14]*m[7]-m[12]*m[6]*m[11]+m[4]*m[14]*m[11]+m[8]*m[6]*m[15]-m[4]*m[10]*m[15])*s;\n    t[ 5] = (m[8]*m[14]*m[3]-m[12]*m[10]*m[3]+m[12]*m[2]*m[11]-m[0]*m[14]*m[11]-m[8]*m[2]*m[15]+m[0]*m[10]*m[15])*s;\n    t[ 6] = (m[12]*m[6]*m[3]-m[4]*m[14]*m[3]-m[12]*m[2]*m[7]+m[0]*m[14]*m[7]+m[4]*m[2]*m[15]-m[0]*m[6]*m[15])*s;\n    t[ 7] = (m[4]*m[10]*m[3]-m[8]*m[6]*m[3]+m[8]*m[2]*m[7]-m[0]*m[10]*m[7]-m[4]*m[2]*m[11]+m[0]*m[6]*m[11])*s;\n\n    t[ 8] = (m[8]*m[13]*m[7]-m[12]*m[9]*m[7]+m[12]*m[5]*m[11]-m[4]*m[13]*m[11]-m[8]*m[5]*m[15]+m[4]*m[9]*m[15])*s;\n    t[ 9] = (m[12]*m[9]*m[3]-m[8]*m[13]*m[3]-m[12]*m[1]*m[11]+m[0]*m[13]*m[11]+m[8]*m[1]*m[15]-m[0]*m[9]*m[15])*s;\n    t[10] = (m[4]*m[13]*m[3]-m[12]*m[5]*m[3]+m[12]*m[1]*m[7]-m[0]*m[13]*m[7]-m[4]*m[1]*m[15]+m[0]*m[5]*m[15])*s;\n    t[11] = (m[8]*m[5]*m[3]-m[4]*m[9]*m[3]-m[8]*m[1]*m[7]+m[0]*m[9]*m[7]+m[4]*m[1]*m[11]-m[0]*m[5]*m[11])*s;\n\n    t[12] = (m[12]*m[9]*m[6]-m[8]*m[13]*m[6]-m[12]*m[5]*m[10]+m[4]*m[13]*m[10]+m[8]*m[5]*m[14]-m[4]*m[9]*m[14])*s;\n    t[13] = (m[8]*m[13]*m[2]-m[12]*m[9]*m[2]+m[12]*m[1]*m[10]-m[0]*m[13]*m[10]-m[8]*m[1]*m[14]+m[0]*m[9]*m[14])*s;\n    t[14] = (m[12]*m[5]*m[2]-m[4]*m[13]*m[2]-m[12]*m[1]*m[6]+m[0]*m[13]*m[6]+m[4]*m[1]*m[14]-m[0]*m[5]*m[14])*s;\n    t[15] = (m[4]*m[9]*m[2]-m[8]*m[5]*m[2]+m[8]*m[1]*m[6]-m[0]*m[9]*m[6]-m[4]*m[1]*m[10]+m[0]*m[5]*m[10])*s;\n}\n\nlet binary = { \n    getUint64: getUint64,\n    getUint32: getUint32,\n    getUint16: getUint16,\n    getFloat32: getFloat32,\n    vecMul: vecMul,\n    matMul: matMul,\n    matInv: matInv\n}\n\n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/Binary.js?\n}");

/***/ }),

/***/ "./src/Cache.js":
/*!**********************!*\
  !*** ./src/Cache.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* binding */ Cache)\n/* harmony export */ });\n\nfunction powerOf2(n) {\n\treturn n && (n & (n - 1)) === 0;\n}\n\nvar targetError   = 2.0;    //error won't go lower than this if we reach it\nvar maxError      = 15;     //error won't go over this even if fps is low\nvar minFps        = 15;\nvar maxPending    = 3;\nvar maxBlocked    = 3;\nvar maxReqAttempt = 2;\nvar maxCacheSize  = 1024 *(1<<20); \nvar drawBudget    = 5*(1<<20);\n\nfunction _Cache() {\n    let t = this;\n    t.cortopath = '.';\n\tt.frame = 0;         //keep track of the time\n\n    t.maxCacheSize = maxCacheSize;\n    t.minFps = minFps;\n    t.currentFps = 0;\n    t.targetError = targetError;\n    t.currentError = targetError;\n    t.maxError = maxError;\n    t.realError = 0;\n\n    t.pending = 0;\n    t.maxPending = 3;\n    t.cacheSize = 0;\n    t.candidates = [];   //list of nodes to be loaded\n    t.nodes = new Map();        //for each mesh a list of node ids.\n    \n    t.last_frametime = 0;\n    t.frametime = 0;\n    t.end_frametime = 0;\n\n    t.debug = { \n        verbose : false,  //debug messages\n        nodes   : false,  //color each node\n        draw    : false,  //final rendering call disabled\n        extract : false,  //extraction disabled}\n    }\n\n    t.totswapped = 0; //in the last frame.\n    t.swaprate = 0;\n    t.lastupdate = performance.now();\n}\n\n_Cache.prototype = {\n    getTargetError:  function()      { return this.targetError; },\n    getMinFps:       function()      { return this.minFps; },\n    setMinFps:       function(fps)   { this.minFps = fps; },\n    getMaxCacheSize: function()      { return this.maxCacheSize; },\n    setMaxCacheSize: function(size)  { this.maxCacheSize = size; },\n    setTargetError:  function(error) { this.targetError = error; },\n    \n    loadCorto: function() {\n        let corto = new Worker(this.cortopath + '/corto.em.js');\n        corto.requests = {};\n        corto.count = 0;\n        corto.postRequest = function(node) {\n            corto.postMessage({ buffer: node.buffer, request:this.count, rgba_colors: true, short_index: true, short_normals: true});\n            node.buffer = null;\n            this.requests[this.count++] = node;\n        }\n        corto.onmessage = function(e) {\n            var request = e.data.request;\n            var node = this.requests[request];\n            delete this.requests[request];\n            node.model = e.data.model;\n            node.cache.readyGeometryNode(node.mesh, node.id, node.model);\n        };\n        this.corto = corto;\n    },\n\n    \n    beginFrame: function(fps) { //each context has a separate frame count.\n        let c = this;\n        c.frametime = performance.now();\n        let elapsed =  c.frametime - c.last_frametime;\n        c.last_frametime = c.frametime;\n        if(elapsed < 500)\n            c.currentFps = 0.9*c.currentFps + 0.1*(1000/elapsed);\n\n        fps = c.currentFps;\n\n\t    c.frame++;\n\t    c.candidates = [];\n\t    if(fps && c.minFps) {\n\t\t    c.currentFps = fps;\n\t\t    const r = c.minFps/fps;\n\t\t    if(r > 1.1)\n\t\t\t    c.currentError *= 1.05;\n\t\t    if(r < 0.9)\n\t\t\t    c.currentError *= 0.95;\n\n\t\t    c.currentError = Math.max(c.targetError, Math.min(c.maxError, c.currentError));\n\n\t    } else\n\t\t    c.currentError = c.targetError;\n\n\t    c.rendered = 0;\n\t    c.realError = 1e20;\n        c.totswapped = 0;\n    },\n\n    endFrame: function() {\n\t    this.update();\n    },\n\n\n\n    requestNode: function(mesh, id) {\n\t    mesh.status[id] = 2; \n\n\t    \n\t    this.cacheSize += mesh.nsize[id];\n\t    mesh.reqAttempt[id] = 0;\n\n\t\tif(!this.nodes.has(mesh))\n\t\t\tthis.nodes.set(mesh, new Set());\n\t\tthis.nodes.get(mesh).add(id);\n\n\t    this.requestNodeGeometry(mesh, id);\n\t    this.requestNodeTexture(mesh, id);\n    },\n\n    requestNodeGeometry: function(mesh, id) {\n\t\tthis.pending++;\n\t    mesh.status[id]++;\n\t\tlet url = mesh.deepzoom ? mesh.baseurl + id + \".nxn\" : mesh.url;\n\t\tlet start = mesh.deepzoom ? 0 : mesh.noffsets[id];\n\t\tlet end = mesh.deepzoom ? 0 : mesh.noffsets[id+1];\n\t    let request = mesh.georeq[id] = mesh.httpRequest(url,\n\t\t    start,\n\t\t    end, \n\t\t    ()=>{\n                delete mesh.georeq[id];\n                this.loadNodeGeometry(request, mesh, id);\n\t\t\t\tthis.pending--;\n            },\n\t\t    ()=>{\n                delete mesh.georeq[id];\n\t\t\t    if(this.debug.verbose) console.log(\"Geometry request error!\");\n\t\t\t    this.recoverNode(mesh, id, 0);\n\t\t\t\tthis.pending--;\n\t\t    },\n\t\t    ()=>{\n                delete mesh.georeq[id];\n\t\t\t    if(this.debug.verbose) console.log(\"Geometry request abort!\");\n\t\t\t    this.removeNode(mesh, id);\n\t\t\t\tthis.pending--;\n\t\t    },\n\t\t    'arraybuffer'\n        );\n    },\n\n    requestNodeTexture: function(mesh, id) {\n\n\t    if(!mesh.vertex.texCoord) return;\n\n\t    let tex = mesh.patches[mesh.nfirstpatch[id]*3+2];\n\t    mesh.texref[tex]++;\n\t    mesh.status[id]++;\n\n\t\tlet url = mesh.deepzoom ? mesh.baseurl + tex + \".jpg\" : mesh.url;\n\t\tlet start = mesh.deepzoom ? 0 : mesh.textures[tex];\n\t\tlet end = mesh.deepzoom ? 0 : mesh.textures[tex+1];\n\t    let request = mesh.texreq[tex] = mesh.httpRequest(url,\n\t\t    start,\n\t\t    end,\n\t\t    ()=>{ \n                delete mesh.texreq[tex];\n                this.loadNodeTexture(request, mesh, id, tex); \n\n            },\n\t\t    ()=>{\n                delete mesh.texreq[tex];\n\t\t    \tif(this.debug.verbose) console.log(\"Texture request error!\");\n\t\t\t    this.recoverNode(mesh, id, 1);\n\t\t    },\n\t\t    ()=>{\n                delete mesh.texreq[tex];\n\t\t    \tif(this.debug.verbose) console.log(\"Texture request abort!\");\n\t\t    \tthis.removeNode(mesh, id);\n\t\t    },\n\t\t    'blob'\n\t    );\n    },\n\n    recoverNode: function(mesh, id, mode) {\n\t    if(mesh.status[id] == 0) return;\n\n\t    mesh.status[id]--;\n\n        let t = this;\n\n\t    if(mesh.reqAttempt[id] > maxReqAttempt) {\n\t\t    if(this.debug.verbose) console.log(\"Max request limit for \" + m.url + \" node: \" + n);\n\t\t    t.removeNode(mesh, id);\n\t\t    return;\n\t    }\n\n\t    mesh.reqAttempt[id]++;\n\n\t    switch (mode){\n\t\tcase 0:\n\t\t    t.requestNodeGeometry(mesh, id);\n\t\t    if(this.debug.verbose) console.log(\"Recovering geometry for \" + m.url + \" node: \" + n);\n\t\t    break;\n\t\tcase 1:\n\t\t\tt.requestNodeTexture(mesh, id);\n\t\t\tif(this.debug.verbose) console.log(\"Recovering texture for \" + m.url + \" node: \" + n);\n\t\t\tbreak;\n\t    }\n    },\n\n    loadNodeGeometry: function(request, mesh, id) {\n\t    if(mesh.status[id] == 0) return;\n        \n\t    if(!mesh.compressed)\n\t\t    this.readyGeometryNode(mesh, id, request.response);\n\t    else {\n            if(!this.corto) this.loadCorto();\n\t\t    this.corto.postRequest( { mesh:mesh, id:id, buffer: request.response, cache: this });\n        }\n    },\n\n\n    loadNodeTexture: function(request, mesh, id, texid) {\n        if(mesh.status[id] == 0) {\n            throw \"Should not load texture twice\";\n        }\n\n\t    let blob = request.response;\n        let callback = (img) => {\n            if(mesh.status[id] == 0) //call was aborted.\n                return;\n            mesh.createTexture(texid, img);\n\n\t\t    mesh.status[id]--;\n\n            if(mesh.status[id] == 2)\n                this.readyNode(mesh, id);\n\t\t    }\n\n        if(typeof createImageBitmap != 'undefined') {\n\t\t\ttry {\n\t\t\t\tcreateImageBitmap(blob, { imageOrientation: 'flipY' }).then(callback);\n\t\t\t} catch(error) { //old version of firefox do not support options (but flip anyway)\n\t\t\t\tcreateImageBitmap(blob).then(callback);\n\t\t\t}\n\n        } else { //fallback for IOS\n            var urlCreator = window.URL || window.webkitURL;\n            var img = document.createElement('img');\n            img.onerror = function(e) { console.log(\"Texture loading error!\"); };\n            img.src = urlCreator.createObjectURL(blob);\n    \n            img.onload = function() {\n                urlCreator.revokeObjectURL(img.src);\n                callback(img);\n            }\n        }\n    },\n\n    removeNode: function(mesh, id) {\n        this.nodes.get(mesh).delete(id);\n\n        if(mesh.status[id] == 0) {\n\t\t\tif(this.debug.verbose)\n\t\t\t\tconsole.log(\"Double remove due to abort.\");\n            return; //TODO\n\t\t}\n\n\t    mesh.status[id] = 0;\n\t    if (id in mesh.georeq && mesh.georeq[id].readyState != 4) {\n            mesh.georeq[id].abort();\n            delete mesh.georeq[id];\n\t\t    //this.pending--;\n\t    }\n        mesh.availableNodes--;\n        this.cacheSize -= mesh.nsize[id];\n        mesh.deleteNodeGeometry(id);\n\n\t    if(!mesh.vertex.texCoord) return;\n\n\t    const tex = mesh.patches[mesh.nfirstpatch[id]*3+2]; //TODO assuming one texture per node\n\n\t    if (tex in mesh.texreq && mesh.texreq[tex].readyState != 4) {\n            mesh.texreq[tex].abort();\n            delete mesh.texreq[tex];\n        }\n\n\t    mesh.texref[tex]--;\n    \tif(mesh.texref[tex] == 0) {\n            mesh.deleteTexture(tex);\n        }\n    },\n\n    readyGeometryNode: function(mesh, id, buffer) {\n        if(mesh.status[id] == 0) //call was aborted\n            return;\n        const nv = mesh.nvertices[id];\n        const nf = mesh.nfaces[id];\n\t    let geometry = {};\n\n\t    \n\t    if(!mesh.corto) {\n\t\t    geometry.index  = new Uint16Array(buffer, nv*mesh.vsize,  nf*3);\n            geometry.position =  new Float32Array(buffer, 0, nv*3);\n\n\t\t    var off = nv*12;\n\t\t    if(mesh.vertex.texCoord) {\n                geometry.uv = new Float32Array(buffer, off, nv*2);\n                off += nv*8;\n            }\n            if(mesh.vertex.normal) {\n\t\t\t\tgeometry.normal = new Int16Array(buffer, off, nv*3);\n                off += nv*6;\n\t\t\t}\n\n            if(mesh.vertex.color) {\n                geometry.color = new Uint8Array(buffer, off, nv*4);\n                off += nv*4;\n\t\t\t}\n\n\t\t\n\t    } else {\n            geometry = buffer;\n\t    }\n\n\t    //if(nf == 0)\n    \t//\tscramble(nv, v, no, co);\n\n        mesh.createNodeGeometry(id, geometry);\n\t    mesh.status[id]--;\n\n\t    if(mesh.status[id] == 2) {\n            this.readyNode(mesh, id);\n\t    }\n    },\n\n    //the node is finished, add to cache, and update counters\n    readyNode: function(mesh, id) {\n\n\t    mesh.status[id]--;\n        if(mesh.status[id] != 1) throw \"A ready node should have status ==1\"\n\n\t\t\n\t\tmesh.reqAttempt[id] = 0;\n        //this.pending--;\n        mesh.createNode(id);\n\t\tmesh.availableNodes++;\n\n        for(let callback of mesh.onUpdate)\n            callback();\n        this.update();\n    },\n\n    flush: function(mesh) {\n        if(!this.nodes.has(mesh)) return;\n\n        for(let id of this.nodes.get(mesh))\n            this.removeNode(mesh, id);\n        this.nodes.delete(mesh);\n    }, \n\n    update: function() {\n        if(this.pending >= maxPending)\n            return;\n\n        //the best candidate has the highest error\n        let best = null;\n        for(let c of this.candidates) {\n            if(c.mesh.status[c.id] == 0 && (!best || c.error > best.error)) \n                best = c;\n\t    }\n        if(!best) return;\n\n\t// record amount of data transfer per second.\n    /*\n        let now = performance.now();\n        if(Math.floor(now/1000) > Math.floor(this.lastupdate/1000)) { //new second\n            this.swaprate = (this.totswapped/1000)/(now - this.lastupdate); //transfer in mb/s\n            if(this.debug.verbose)\n            console.log(\"Memory loaded in GPU: \", this.swaprate);\n            this.totswapped = 0;\n            this.lastupdate =  now;\n        }\n    */\n        \n            \n        //make room for new nodes!\n        \n\t    while(this.cacheSize > this.maxCacheSize) {\n            let worst = null;\n            \n            //find node with smallest error in cache and remove it if worse than the best candidate.\n            for(let [mesh, ids] of this.nodes) {\n                for(let id of ids) {\n                //we need to recompute the errors for the cache, as if not traversed doesn't get updated.\n                    let error = mesh.errors[id];\n                    let frame = mesh.frames[id];\n                    if( !worst || error < worst.error) {\n                        worst = { id: id, frame: frame, error: error, mesh: mesh }\n                    }\n                }\n            }\n            if(!worst || worst.error >= best.error*0.9) {\n                //(worst.frame + 30 >= best.frame && )) //dont' remove if  the best candidate is not good enogh\n                return;\n            }\n\t\t    this.removeNode(worst.mesh, worst.id);\n\t    }\n        this.totswapped += best.mesh.nsize[best.id];\n        this.candidates = this.candidates.filter(e => e.mesh == best.mesh && e.id == best.id);\n    \tthis.requestNode(best.mesh, best.id);\n\t    this.update();  //try again.\n    }\n};\n\nlet Cache = new _Cache;\n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/Cache.js?\n}");

/***/ }),

/***/ "./src/Mesh.js":
/*!*********************!*\
  !*** ./src/Mesh.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mesh: () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _Binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Binary.js */ \"./src/Binary.js\");\n\n\n/* MESH DEFINITION */\nlet Debug = { verbose: true };\n\nlet glP = WebGLRenderingContext.prototype;\nlet attrGlMap = [glP.NONE, glP.BYTE, glP.UNSIGNED_BYTE, glP.SHORT, glP.UNSIGNED_SHORT, glP.INT, glP.UNSIGNED_INT, glP.FLOAT, glP.DOUBLE];\nlet attrSizeMap = [0, 1, 1, 2, 2, 4, 4, 4, 8];\n\n//All addresses in the file are n*256 so,  256 * 2^32 is the max size of a Nxs file \nvar padding = 256;\n\nlet Mesh = function(url) {\n    var t = this;\n    t.isReady = false;\n    t.onLoad = [];\n    t.onUpdate = [];\n    t.reqAttempt = 0;\n    t.georeq = {}; //keeps track of existing httprequests\n    t.texreq = {};\n    t.frame = 0; //last time this mesh was traversed in rendering.\n    t.availableNodes = 0\n    if(url)\n        t.open(url);\n}\n\nMesh.prototype = {\n    open: function(url) {\n        let mesh = this;\n        mesh.url = url;\n        mesh.httpRequest(url,\n            0,\n            88,\n            function() {\n                if(Debug.verbose) console.log(\"Loading header for \" + mesh.url);\n                let view = new DataView(this.response);\n                view.offset = 0;\n                mesh.reqAttempt++;\n                const header = mesh.importHeader(view);\n                if(!header) {\n                    if(Debug.verbose) console.log(\"Empty header!\");\n                    if(mesh.reqAttempt < maxReqAttempt) mesh.open(mesh.url + '?' + Math.random()); // BLINK ENGINE CACHE BUG PATCH\n                    return;\n                }\n                mesh.reqAttempt = 0;\n                for(let i in header)\n                    mesh[i] = header[i];\n                mesh.vertex = mesh.signature.vertex;\n                mesh.face = mesh.signature.face;\n                mesh.renderMode = mesh.face.index?[\"FILL\", \"POINT\"]:[\"POINT\"];\n                mesh.compressed = (mesh.signature.flags & (2 | 4)); //meco or corto\n                mesh.meco = (mesh.signature.flags & 2);\n                mesh.corto = (mesh.signature.flags & 4);\n\n\t\t\t\tmesh.deepzoom = (mesh.signature.flags & 8);\n\t\t\t\tif(mesh.deepzoom)\n\t\t\t\t\tmesh.baseurl = url.substr(0, url.length -4) + '_files/';\n\n\n                mesh.requestIndex();\n            },\n            function() { console.log(\"Open request error!\");},\n            function() { console.log(\"Open request abort!\");}\n        );\n    },\n\n    httpRequest: function(url, start, end, load, error, abort, type) {\n        if(!type) type = 'arraybuffer';\n        var r = new XMLHttpRequest();\n        r.open('GET', url, true);\n        r.responseType = type;\n\t\tif(end)\n\t\t\tr.setRequestHeader(\"Range\", \"bytes=\" + start + \"-\" + (end -1));\n        r.onload = function(){\n            switch (this.status){\n                case 0:\n//\t\t\t\t\tconsole.log(\"0 response: server unreachable.\");//returned in chrome for local files\n\t\t\t\t\terror();\n\t\t\t\t\tbreak;\n                case 206:\n//\t\t\t\t\tconsole.log(\"206 response: partial content loaded.\");\n                    load.bind(this)();\n                    break;\n                case 200:\n//\t\t\t\t\tconsole.log(\"200 response: server does not support byte range requests.\");\n\t\t\t\t\tif(end == 0)\n\t\t\t\t\t\tload.bind(this)();\n\t\t\t\t\telse\n\t\t\t\t\t\terror();\n\t\t\t\t\tbreak;\n            }\n        };\n        r.onerror = error;\n        r.onabort = abort;\n        r.send();\n        return r;\n    },\n\n    requestIndex: function() {\n        var mesh = this;\n        var end = 88 + mesh.nodesCount*44 + mesh.patchesCount*12 + mesh.texturesCount*68;\n        mesh.httpRequest(this.url,\n            88,\n            end,\n            function() { if(Debug.verbose) console.log(\"Loading index for \" + mesh.url); mesh.handleIndex(this.response); },\n            function() { console.log(\"Index request error!\");},\n            function() { console.log(\"Index request abort!\");}\n        );\n    },\n\n    handleIndex: function(buffer) {\n        let t = this;\n        let view = new DataView(buffer);\n        view.offset = 0;\n\n        const n = t.nodesCount;\n\n        t.noffsets  = new Uint32Array(n);\n        t.nvertices = new Uint32Array(n);\n        t.nfaces    = new Uint32Array(n);\n        t.nerrors   = new Float32Array(n);\n        t.nspheres  = new Float32Array(n*5);\n        t.nsize     = new Float32Array(n);\n        t.nfirstpatch = new Uint32Array(n);\n\n        for(let i = 0; i < n; i++) {\n            t.noffsets[i] = padding*(0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view); //offset\n            t.nvertices[i] = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint16)(view);        //verticesCount\n            t.nfaces[i] = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint16)(view);           //facesCount\n            t.nerrors[i] = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view);\n            view.offset += 8;                        //skip cone\n            for(let k = 0; k < 5; k++)\n                t.nspheres[i*5+k] = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view);       //sphere + tight\n            t.nfirstpatch[i] = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);          //first patch\n        }\n        t.sink = n -1;\n\n        t.patches = new Uint32Array(view.buffer, view.offset, t.patchesCount*3); //noded, lastTriangle, texture\n        t.nroots = t.nodesCount;\n        for(let j = 0; j < t.nroots; j++) {\n            for(let i = t.nfirstpatch[j]; i < t.nfirstpatch[j+1]; i++) {\n                if(t.patches[i*3] < t.nroots)\n                    t.nroots = t.patches[i*3];\n            }\n        }\n\n        view.offset += t.patchesCount*12;\n\n        t.textures = new Uint32Array(t.texturesCount);\n        t.texref = new Uint32Array(t.texturesCount);\n        for(let i = 0; i < t.texturesCount; i++) {\n            t.textures[i] = padding*(0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n            view.offset += 16*4; //skip proj matrix\n        }\n\n        t.vsize = 12 + (t.vertex.normal?6:0) + (t.vertex.color?4:0) + (t.vertex.texCoord?8:0);\n        t.fsize = 6;\n\n        //problem: I have no idea how much space a texture is needed in GPU. 10x factor assumed.\n        let tmptexsize = new Uint32Array(n-1);\n        let tmptexcount = new Uint32Array(n-1);\n        for(let i = 0; i < n-1; i++) {\n            for(let p = t.nfirstpatch[i]; p != t.nfirstpatch[i+1]; p++) {\n                let tex = t.patches[p*3+2];\n                tmptexsize[i] += t.textures[tex+1] - t.textures[tex];\n                tmptexcount[i]++;\n            }\n            t.nsize[i] = t.vsize*t.nvertices[i] + t.fsize*t.nfaces[i];\n        }\n        for(let i = 0; i < n-1; i++) {\n            t.nsize[i] += 10*tmptexsize[i]/tmptexcount[i];\n        }\n\n        t.status = new Uint8Array(n); //0 for none, 1 for ready, 2+ for waiting data\n        t.frames = new Uint32Array(n);\n        t.errors = new Float32Array(n); //biggest error of instances\n        t.reqAttempt = new Uint8Array(n);\n        \n        t.isReady = true;\n        for(let callback of t.onLoad)\n            callback(this);\n    },\n\n    importAttribute: function(view) {\n        let a = {};\n        a.type = view.getUint8(view.offset++, true);\n        a.size = view.getUint8(view.offset++, true);\n        a.glType = attrGlMap[a.type];\n        a.normalized = a.type < 7;\n        a.stride = attrSizeMap[a.type]*a.size;\n        if(a.size == 0) return null;\n        return a;\n    },\n\n    importElement: function(view) {\n        let e = [];\n        for(let i = 0; i < 8; i++)\n            e[i] = this.importAttribute(view);\n        return e;\n    },\n\n    importVertex: function(view) {\t//enum POSITION, NORMAL, COLOR, TEXCOORD, DATA0\n        const e = this.importElement(view);\n        let color = e[2];\n        if(color) {\n            color.type = 2; //unsigned byte\n            color.glType = attrGlMap[2];\n        }\n        return { position: e[0], normal: e[1], color: e[2], texCoord: e[3], data: e[4] };\n    },\n\n    //enum INDEX, NORMAL, COLOR, TEXCOORD, DATA0\n    importFace: function(view) {\n        const e = this.importElement(view);\n        let color = e[2];\n        if(color) {\n            color.type = 2; //unsigned byte\n            color.glType = attrGlMap[2];\n        }\n        return { index: e[0], normal: e[1], color: e[2], texCoord: e[3], data: e[4] };\n    },\n\n    importSignature: function(view) {\n        let s = {};\n        s.vertex = this.importVertex(view);\n        s.face = this.importFace(view);\n        s.flags = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        return s;\n    },\n\n    importHeader: function(view) {\n        const magic = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        if(magic != 0x4E787320) return null;\n        let h = {};\n        h.version = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        h.verticesCount = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint64)(view);\n        h.facesCount = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint64)(view);\n        h.signature = this.importSignature(view);\n        h.nodesCount = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        h.patchesCount = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        h.texturesCount = (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getUint32)(view);\n        h.sphere = {\n            center: [(0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view), (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view), (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view)],\n            radius: (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.getFloat32)(view)\n        };\n        return h;\n    },\n    //OVERRIDE THESE METHOS\n\n    //assemble node and geometry\n    createNode: function(id) {},\n\n    createNodeGeometry: function(id, data) {},\n    deleteNodeGeometry: function(id) {},\n\n    createTexture: function(id, image) {},\n    deleteTexture: function(id) {},\n};\n\n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/Mesh.js?\n}");

/***/ }),

/***/ "./src/Nexus3D.js":
/*!************************!*\
  !*** ./src/Nexus3D.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* reexport safe */ _Cache_js__WEBPACK_IMPORTED_MODULE_3__.Cache),\n/* harmony export */   Nexus3D: () => (/* binding */ Nexus3D)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Traversal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Traversal.js */ \"./src/Traversal.js\");\n/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mesh.js */ \"./src/Mesh.js\");\n/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Cache.js */ \"./src/Cache.js\");\n\n\n\n\n\nclass Nexus3D extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n\n\tconstructor(url, renderer, options = {}) {\n\n\t\tsuper();\n\n\t\tthis.patchWebGLRenderer(renderer);\n\n\t\tObject.assign(this, {\n\t\t\tisNXS: true,\n\t\t\ttype:'NXS',\n\t\t\turl: url,\n\t\t\tgl: renderer.getContext(),\n\t\t\tXRMode: false, //set to true to avoid flickering due to double eye rendering.\n\t\t\tmaterial: null,\n\n\t\t\tautoUpdate: true,\n\t\t\tmesh: new _Mesh_js__WEBPACK_IMPORTED_MODULE_2__.Mesh(),\n\t\t\tvbo: [],\n\t\t\tibo: [],\n\t\t\tvao: [],\n\t\t\ttextures: [],\n\t\t\tattributes: {},  //here we store the uniform attributes of the shader.\n\n\t\t\tbasemesh: null,  //highest level of the nexus, for picking\n\t\t});\n\n\t\tif('material' in options)\n\t\t\tthis.material = options.material;\n\t\tif(!this.material) \n\t\t\tthis.material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial();\n\t\t\t\n\t\tfor(let call of ['onLoad', 'onUpdate', 'onProgress']) {\n\t\t\tthis['_' + call] = [];\n\t\t\tif(call in options)\n\t\t\t\tthis['_' + call].push(options[call])\n\t\t}\n\n\t\tif(this.url) {\n\t\t\tif(typeof url == 'object') {\n\t\t\t\tthis.nxs = this.url;\n\t\t\t\tthis.nxs.onLoad.push((m) => { \n\t\t\t\t\tthis.mesh = this.nxs.mesh;\n\t\t\t\t\tthis.traversal = this.nxs.traversal;\n\t\t\t\t\tthis.cache = this.nxs.cache;\n\t\t\t\t\tthis.vbo = this.nxs.vbo;\n\t\t\t\t\tthis.ibo = this.nxs.ibo;\n\t\t\t\t\tthis.vao = this.nxs.vao;\n\t\t\t\t\tthis.textures = this.nxs.textures;\n\t\t\t\t\tthis.onLoadCallback(this); \n\t\t\t\t});\n\t\t\t} else\n\t\t\t\tthis.open(this.url);\n\t\t}\n\t}\n\n\tcopy(source) {\n\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(this, source, false);\n\t\tthrow new Error(\"Can't really copy a Nexus3D object.\");\n\t\t// removed by dead control flow\n\n\t}\n\n\t\n\topen(url) {\n\t\tlet t = this;\n\t\tthis.mesh.open(url);\n\t\tthis.mesh.createNode         = (id)           => { };\n\t\tthis.mesh.createNodeGeometry = (id, geometry) => { t.createNodeGeometry(id, geometry); };\n\t\tthis.mesh.createTexture      = (id, image)    => { t.createTexture(id, image); };\n\t\tthis.mesh.deleteNodeGeometry = (id)           => { t.deleteNodeGeometry(id); };\n\t\tthis.mesh.deleteTexture      = (id)           => { t.deleteTexture(id); };\n\t\tthis.mesh.onLoad.push(() => { t.onLoadCallback(); });\n\t\tthis.mesh.onUpdate.push(() => { \n\t\t\tfor(let callback of t._onUpdate) callback(this); \n\t\t\tfor(let callback of t._onProgress) callback(this, this.mesh.availableNodes, this.mesh.nodesCount); \n\t\t});\n\n\t\tthis.traversal = new _Traversal_js__WEBPACK_IMPORTED_MODULE_1__.Traversal();\n\t\tthis.cache = _Cache_js__WEBPACK_IMPORTED_MODULE_3__.Cache; //new Cache();\n\t\tthis.textures = {};        \n\t}\n\n\tset onLoad(callback) {\n\t\tthis._onLoad.push(callback);\n\t}\n\n\tset onUpdate(callback) {\n\t\tthis._onUpdate.push(callback);\n\t}\n\n\tset onProgress(callback) {\n\t\tthis._onProgress.push(callback);\n\t}\n\n\t//TODO this is not really needed, we might just conform to THREEJS standard of updating.\n\t/*set material(material) {\n\t\tthis.material = material;\n\t\tthis.material.needsUpdate = true;\n\t}*/\n\t\n\tupdateMaterials() {\n\t\tif(this.material.map !== false && this.mesh.vertex.texCoord)\n\t\t\tthis.material.map = this.material_texture;\n\n\t\tif(this.mesh.vertex.color)\n\t\t\tthis.material.vertexColors = true; \n\t\tthis.material.needsUpdate = true; \n\t}\n\n\tonLoadCallback() {\n\t\tconst c = this.mesh.sphere.center;\n\t\tconst center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(c[0], c[1], c[2]);\n\t\tconst radius = this.mesh.sphere.radius;\n\t\tthis.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere(center, radius);\n\n\t\tvar geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(3), 3));\n\t\t\n\t\tif(this.mesh.vertex.normal)\n\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(3), 3));\n\t\tif(this.mesh.vertex.color)\n\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(4), 4));\n\t\tif(this.mesh.vertex.texCoord)\n\t\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(2), 2));\n\n\t\tif(this.mesh.vertex.texCoord) {\n\t\t\tthis.material_texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture( new Uint8Array([1, 1, 1, 1]), 1, 1, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat );\n\t\t\tthis.material_texture.needsUpdate = true;\n\t\t}\n\n\t\tthis.updateMaterials();\n\t\tthis.geometry = geometry;\n\t\t\n\t\tthis.frustumCulled = false;\n\t\t\t\n\t\tfor(let callback of this._onLoad)\n\t\t\tcallback(this);\n\t}\n\n\trenderBufferDirect(renderer, scene, camera, geometry, material, group) {\n\t\tlet s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();\n\t\trenderer.getViewport(s);\n\n\t   \t//object modelview is multiplied by camera during rendering, we need to do it here for visibility computations\n\t\tthis.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, this.matrixWorld );\n\t\tif(s.x == 0 && this.XRMode) { //hack to only traverse on the left eye\n\t\t\tthis.traversal.updateView(s, camera.projectionMatrix.elements, this.modelViewMatrix.elements);\n\t\tthis.instance_errors = this.traversal.traverse(this.mesh, this.cache);\n\t\t}\n\t\t//threejs increments version when setting neeedsUpdate\n\t\t/*if(this.material.version > 0) {\n\t\t\tthis.updateMaterials();\n\t\t\tthis.material.version = 0;\n\t\t\tfor(let callback of this.onUpdate) \n\t\t\t\tcallback(this); \n\t\t}*/\n\t\tlet gl = this.gl;\n\t\tlet program = gl.getParameter(gl.CURRENT_PROGRAM);\n\n\t\t//TODO these calls could be cached saving attrs per each material.\n\t\tlet attr = this.attributes;\n\t\tattr.position = gl.getAttribLocation(program, \"position\");\n\t\tattr.normal   = gl.getAttribLocation(program, \"normal\");\n\t\tattr.color    = gl.getAttribLocation(program, \"color\");\n\t\tattr.uv       = gl.getAttribLocation(program, \"uv\");\n\t\tattr.size     = gl.getUniformLocation(program, \"size\");\n\t\tattr.scale    = gl.getUniformLocation(program, \"scale\");\n\n\t\tlet map_location = gl.getUniformLocation(program, \"map\"); \n\t\tattr.map      = map_location ? gl.getUniform(program, map_location) : null;\n\t\t\n\t\n\t\t//hack to detect if threejs using point or triangle shaders\n\t\t//instance.mode = attr.size ? \"POINT\" : \"FILL\";\n\t\t//if(attr.size != -1) \n\t\t//    instance.pointsize = material.size;\n\t\n\t\t//can't find docs or code on how material.scale is computed in threejs.\n\t\t//if(attr.scale != -1)\n\t\t//    instance.pointscale = 2.0;\n\n\t\tthis.setVisibility();\n\t}\n\n\tsetVisibility() {\n\t\t//set visibile what is visible!\n\t\tlet t = this.traversal;\n\t\tlet m = this.mesh;\n\t\n\t\tif(!m.isReady)\n\t\t\treturn;\n\t\tlet rendered = 0;\n\t\t\n\t\tlet attr = this.attributes;\n\t\tlet mesh = this.mesh;\n\t\tlet gl = this.gl;\n\t\tlet gl2 = gl instanceof WebGL2RenderingContext;\n\t\tlet state = attr.uv + 10*attr.color + 100*attr.normal;\n\t\t\t\n\t\tfor(let id = 0; id < m.nodesCount; id++) {\n//            let err = m.nerrors[id];\n\n\t\t\tif(!t.selected[id]) continue;\n\n\t\t\t//check for children: if all are selected, bail out.\n\t\t\t{\n\t\t\t\tlet visible = false;\n\t\t\t\tlet offset = 0;\n\t\t\t\tlet end = 0;\n\t\t\t\tlet last = m.nfirstpatch[id+1]-1;\n\t\t\t\tfor (var p = m.nfirstpatch[id]; p < m.nfirstpatch[id+1]; ++p) {\n\t\t\t\t\tvar child = m.patches[p*3];\n\t\n\t\t\t\t\tif(!t.selected[child]) {\n\t\t\t\t\t\tvisible = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!visible) continue;\n\t\t\t}\n\n\t\t\tvar sp = m.nspheres;\n\t\t\tvar off = id*5;\n\t\t\tif(!t.isVisible(sp[off], sp[off+1], sp[off+2], sp[off+4])) //tight radius\n\t\t\t\tcontinue;\n\t\n\t\t\tlet doBind = true;\n\n\t\t\tif(gl2) {\n\t\t\t\tif(state in this.vao[id])\n\t\t\t\t\tdoBind = false;\n\t\t\t\telse\n\t\t\t\t\tthis.vao[id][state] = gl.createVertexArray();\n\t\t\t\t\t\n\t\t\t   \tgl.bindVertexArray(this.vao[id][state]);\n\t\t\t}\n\t\t\t\n\t\t\tif(doBind) { \n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vbo[id]);\n\t\t\t   \tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo[id]);\n\t\n\t\t\t\tgl.vertexAttribPointer(attr.position, 3, gl.FLOAT, false, 12, 0);\n\t\t\t\tgl.enableVertexAttribArray(attr.position);\n\t\n\t\t\t\tlet nv = this.mesh.nvertices[id];\n\t\t\t\tlet offset = nv*12;\n\t\n\t\t\t\tif(mesh.vertex.texCoord) {\n\t\t\t\t\tif(attr.uv >= 0) {\n\t\t\t\t\t\tgl.vertexAttribPointer(attr.uv, 2, gl.FLOAT, false, 8, offset);\n\t\t\t\t\t\tgl.enableVertexAttribArray(attr.uv);\n\t\t\t\t\t}\n\t\t\t\t\toffset += nv*8;\n\t\t\t\t}\n\t\t\t\tif(mesh.vertex.color) {\n\t\t\t\t\tif(attr.color >= 0) {\n\t\t\t\t\t\tgl.vertexAttribPointer(attr.color, 4, gl.UNSIGNED_BYTE, true, 4, offset);\n\t\t\t\t\t\tgl.enableVertexAttribArray(attr.color);\n\t\t\t\t\t}\n\t\t\t\t\toffset += nv*4;\n\t\t\t\t}\n\t\t\t\tif(mesh.vertex.normal) {\n\t\t\t\t\tif(attr.normal >= 0) {\n\t\t\t\t\t\tgl.vertexAttribPointer(attr.normal, 3, gl.SHORT, true, 6, offset);\n\t\t\t\t\t\tgl.enableVertexAttribArray(attr.normal);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(this.cache.debug.nodes) {\n\t\t\t\t\tgl.disableVertexAttribArray(attr.color);\n\n\t\t\t\t\tvar error = this.instance_errors[id]; //this.mesh.errors[id];\n\t\t\t\t\tvar palette = [\n\t\t\t\t\t\t[1, 1, 1, 1], //white\n\t\t\t\t\t\t[1, 1, 1, 1], //white\n\t\t\t\t\t\t[0, 1, 0, 1], //green\n\t\t\t\t\t\t[0, 1, 1, 1], //cyan\n\t\t\t\t\t\t[1, 1, 0, 1], //yellow\n\t\t\t\t\t\t[1, 0, 1, 1], //magenta\n\t\t\t\t\t\t[1, 0, 0, 1]  //red\n\t\t\t\t\t];\n\t\t\t\t\tlet w = Math.min(5.99, Math.max(0, Math.log2(error)/2));\n\t\t\t\t\tlet low = Math.floor(w);\n\t\t\t\t\tw -= low;\n\t\t\t\t\tlet color = [];\n\t\t\t\t\tfor( let k = 0; k < 4; k++)\n\t\t\t\t\t\tcolor[k] = palette[low][k]*(1-w) + palette[low+1][k]*w;\n\t\t\t\t\t\n\t\t\t\t\tgl.vertexAttrib4fv(attr.color, color);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cache.realError = Math.min(this.mesh.errors[id], this.cache.realError);\n\t\t\t\n\t\t\tlet offset = 0;\n\t\t\tlet end = 0;\n\t\t\tlet last = m.nfirstpatch[id+1]-1;\n\t\t\tfor (let p = m.nfirstpatch[id]; p < m.nfirstpatch[id+1]; ++p) {\n\t\t\t\tlet child = m.patches[p*3];\n\t\n\t\t\t\tif(!t.selected[child]) {\n\t\t\t\t\tend = m.patches[p*3+1];\n\t\t\t\t\tif(p < last) //we join patches if possible.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(end > offset) {\n\t\t\t\t\tif(m.vertex.texCoord && attr.uv >= 0) {\n\t\t\t\t\t\tvar tex = m.patches[p*3+2];\n\t\t\t\t\t\tif(tex != -1) { //bind texture\n\t\t\t\t\t\t\tvar texid = this.textures[tex];\n\t\t\t\t\t\t\tgl.activeTexture(gl.TEXTURE0 + attr.map);\n\t\t\t\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet mode = this.material.wireframe ? gl.LINE_STRIP : gl.TRIANGLES;\n\n\t\t\t\t\tgl.drawElements(mode, (end - offset) * 3, gl.UNSIGNED_SHORT, offset * 6);\n\t\t\t\t\trendered += end - offset;\n\t\t\t\t}\n\t\t\t\toffset = m.patches[p*3+1];\n\t\t\t}\n\t\t}\n\t\tthis.cache.rendered += rendered;\n\t}\n\n\tcreateNodeGeometry(id, data) {\n\t\tlet m = this.mesh;\n\t\tvar nv = m.nvertices[id];\n\t\tvar nf = m.nfaces[id];\n\t\tlet indices  = data.index;\n\t\tlet vertices = new ArrayBuffer(nv*m.vsize);\n\t\tvar position = new Float32Array(vertices, 0, nv*3);\n\t\tposition.set(data.position);\n\t\tvar off = nv*12;\n\t\tif(m.vertex.texCoord) {\n\t\t\tvar uv = new Float32Array(vertices, off, nv*2);\n\t\t\tuv.set(data.uv);\n\t\t\toff += nv*8;\n\t\t}\n\t\tif(m.vertex.color) {\n\t\t\tvar color = new Uint8Array(vertices, off, nv*4);\n\t\t\tcolor.set(data.color);\n\t\t\toff += nv*4;\n\t\t}\n\t\tif(m.vertex.normal) {\n\t\t\tvar normal = new Int16Array(vertices, off, nv*3);\n\t\t\tnormal.set(data.normal);\n\t\t\toff += nv*6;\n\t\t}\n\t\t\n\t\t//needed for approximate picking.\n\t\tif(id < this.mesh.nroots) {\n\t\t\tlet basegeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tbasegeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(data.position, 3 ) );\n\t\t\tbasegeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(data.normal, 3 ) );\n\t\t\tbasegeometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( data.index, 1 ) );\n\n\t\t\tthis.basemesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(basegeometry, this.material);\n\t\t\tthis.basemesh.visible = false;\n\t\t\tthis.add(this.basemesh);\n\t\t}\n\t\t\n\t\tvar gl = this.gl\n\t\tthis.vao[id] = {}; //one for each attrib combination in use (casting shadows for example).\n\t\tgl.bindVertexArray(null);\n\t\t\n\t\tvar vbo = this.vbo[id] = gl.createBuffer();\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\t\tvar ibo = this.ibo[id] = gl.createBuffer();\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n\t}\n\n\tcreateTexture(id, image) {\n\t\tlet gl = this.gl;\n\t\tvar flip = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\t\tlet tex = this.textures[id] = gl.createTexture();\n\t\tgl.bindTexture(gl.TEXTURE_2D, tex);\n\n\t\t//TODO some textures might be alpha only! save space\n\t\tlet internalFormat;\n\t\tif (this.material && this.material.map && this.material.map.colorSpace === three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n\t\t\tinternalFormat = gl.RGBA;\n\t\t} else if (typeof gl.SRGB8_ALPHA8 !== 'undefined') {\n\t\t\tinternalFormat = gl.SRGB8_ALPHA8;\n\t\t} else {\n\t\t\tinternalFormat = gl.RGBA;\n\t\t}\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n\t\tfunction powerOf2(n) { return n && (n & (n - 1)) === 0; }\n\t\tif(!(gl instanceof WebGLRenderingContext) || (powerOf2(image.width) && powerOf2(image.height))) {\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n\t\t\tgl.generateMipmap(gl.TEXTURE_2D);\n\t\t} else {\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t}\n\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip);   \n\t}\n\t//schedule for removal of this node( might not want to delete it in the middle of something.\n\t//TODO check if this is really needed!\n\tdeleteNodeGeometry(id) {\n\t\tthis.gl.deleteBuffer(this.vbo[id]);\n\t\tthis.gl.deleteBuffer(this.ibo[id]);\n\n\t\tthis.vbo[id] = this.ibo[id] = null;\n\t\tif(this.vao[id]) //node might have been loaded and unloaded before a rendering\n\t\t\tfor(const [state, vao] of Object.entries(this.vao[id]))\n\t\t\t\tthis.gl.deleteVertexArray(vao);\n\t\tthis.vao[id] = null;\n\t}\n\n\tdeleteTexture(tex) {\n\t\tif(!this.textures[tex])\n\t\t\treturn;\n\t\t//\tthrow \"Deleting missing texture!\"\n\n\t\tthis.gl.deleteTexture(this.textures[tex]);\n\t\tthis.textures[tex] = 0;\n\t}\n\n\tflush() {\n\t\tthis.cache.flush(this.mesh);\n\t}\n\n\tdispose() {\n\t\tthis.flush();\n\t\tfor(let child of this.children)\n\t\t\tchild.geometry.dispose();\n\t}\n\n\ttoJSON(meta) {\n\t\tthrow new Error(\"Can't convert to json.\");\n\t}\n\n\tpatchWebGLRenderer(renderer) {\n\t\tif(renderer.nexusPatched) return;\n\t\tlet f = renderer.renderBufferDirect;\n\t\trenderer.renderBufferDirect = ( camera, scene, geometry, material, object, group) => { \n\t\t\tf( camera, scene, geometry, material, object, group );\n\t\t\tif ( object.renderBufferDirect)\n\t\t\t\tobject.renderBufferDirect(renderer, scene, camera, geometry, material, group);\n\t\t};\n\t\trenderer.originalRender = renderer.render;\n\t\trenderer.render = (scene, camera) => {\n\t\t\t_Cache_js__WEBPACK_IMPORTED_MODULE_3__.Cache.beginFrame(30);\n\t\t\trenderer.originalRender(scene, camera);\n\t\t\t_Cache_js__WEBPACK_IMPORTED_MODULE_3__.Cache.endFrame();\n\t\t}\n\t\trenderer.nexusPatched = true;\n\t}        \n\n}\n\n\n\n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/Nexus3D.js?\n}");

/***/ }),

/***/ "./src/PriorityQueue.js":
/*!******************************!*\
  !*** ./src/PriorityQueue.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PriorityQueue: () => (/* binding */ PriorityQueue)\n/* harmony export */ });\n    \n function PriorityQueue(max_length) {\n    this.error = new Float32Array(max_length);\n    this.data = new Int32Array(max_length);\n    this.size = 0;\n}\n\nPriorityQueue.prototype = {\n    push: function(data, error) {\n        this.data[this.size] = data;\n        this.error[this.size] = error;\n        this.bubbleUp(this.size);\n        this.size++;\n    },\n\n    pop: function() {\n        var result = this.data[0];\n        this.size--;\n        if(this.size > 0) {\n            this.data[0] = this.data[this.size];\n            this.error[0] = this.error[this.size];\n            this.sinkDown(0);\n        }\n        return result;\n    },\n\n    bubbleUp: function(n) {\n        var data = this.data[n];\n        var error = this.error[n];\n        while (n > 0) {\n            var pN = ((n+1)>>1) -1;\n            var pError = this.error[pN];\n            if(pError > error)\n                break;\n            //swap\n            this.data[n] = this.data[pN];\n            this.error[n] = pError;\n            this.data[pN] = data;\n            this.error[pN] = error;\n            n = pN;\n        }\n    },\n\n    sinkDown: function(n) {\n        var data = this.data[n];\n        var error = this.error[n];\n\n        while(true) {\n            var child2N = (n + 1) * 2;\n            var child1N = child2N - 1;\n            var swap = -1;\n            if (child1N < this.size) {\n                var child1Error = this.error[child1N];\n                if(child1Error > error)\n                    swap = child1N;\n            }\n            if (child2N < this.size) {\n                var child2Error = this.error[child2N];\n                if (child2Error > (swap == -1 ? error : child1Error))\n                    swap = child2N;\n            }\n\n            if (swap == -1) break;\n\n            this.data[n] = this.data[swap];\n            this.error[n] = this.error[swap];\n            this.data[swap] = data;\n            this.error[swap] = error;\n            n = swap;\n        }\n    }\n};\n\n\n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/PriorityQueue.js?\n}");

/***/ }),

/***/ "./src/Traversal.js":
/*!**************************!*\
  !*** ./src/Traversal.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Traversal: () => (/* binding */ Traversal)\n/* harmony export */ });\n/* harmony import */ var _Binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Binary.js */ \"./src/Binary.js\");\n/* harmony import */ var _PriorityQueue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PriorityQueue.js */ \"./src/PriorityQueue.js\");\n\n\n\nfunction Traversal() {\n    let t = this;\n    t.maxBlocked    = 30;\n\n    t.modelMatrix      = new Float32Array(16);\n    t.viewMatrix       = new Float32Array(16);\n    t.projectionMatrix = new Float32Array(16);\n    t.modelView        = new Float32Array(16);\n    t.modelViewInv     = new Float32Array(16);\n    t.modelViewProj    = new Float32Array(16);\n    t.modelViewProjInv = new Float32Array(16);\n    t.planes           = new Float32Array(24);\n    t.viewport         = new Float32Array(4);\n    t.viewpoint        = new Float32Array(4);\n}\n\nTraversal.prototype = {\n    updateView: function(viewport, projection, modelView) {\n        let t = this;\n\n        for(let i = 0; i < 16; i++) {\n            t.projectionMatrix[i] = projection[i];\n            t.modelView[i] = modelView[i];\n        }\n        for(let i = 0; i < 4; i++)\n            t.viewport[i] = viewport[i];\n\n        (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.matMul)(t.projectionMatrix, t.modelView, t.modelViewProj);\n        (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.matInv)(t.modelViewProj, t.modelViewProjInv);\n\n        (0,_Binary_js__WEBPACK_IMPORTED_MODULE_0__.matInv)(t.modelView, t.modelViewInv);\n        t.viewpoint[0] = t.modelViewInv[12];\n        t.viewpoint[1] = t.modelViewInv[13];\n        t.viewpoint[2] = t.modelViewInv[14];\n        t.viewpoint[3] = 1.0;\n\n\n        const m = t.modelViewProj;\n        const mi = t.modelViewProjInv;\n        let p = t.planes;\n\n        //frustum planes Ax + By + Cz + D = 0;\n        p[0]  =  m[0] + m[3]; p[1]  =  m[4] + m[7]; p[2]  =  m[8] + m[11];  p[3]  =  m[12] + m[15]; //left\n        p[4]  = -m[0] + m[3]; p[5]  = -m[4] + m[7]; p[6]  = -m[8] + m[11];  p[7]  = -m[12] + m[15]; //right\n        p[8]  =  m[1] + m[3]; p[9]  =  m[5] + m[7]; p[10] =  m[9] + m[11];  p[11] =  m[13] + m[15]; //bottom\n        p[12] = -m[1] + m[3]; p[13] = -m[5] + m[7]; p[14] = -m[9] + m[11];  p[15] = -m[13] + m[15]; //top\n        p[16] = -m[2] + m[3]; p[17] = -m[6] + m[7]; p[18] = -m[10] + m[11]; p[19] = -m[14] + m[15]; //near\n        p[20] = -m[2] + m[3]; p[21] = -m[6] + m[7]; p[22] = -m[10] + m[11]; p[23] = -m[14] + m[15]; //far\n\n        //normalize planes to get also correct distances\n        for(let i = 0; i < 24; i+= 4) {\n            let l = Math.sqrt(p[i]*p[i] + p[i+1]*p[i+1] + p[i+2]*p[i+2]);\n            p[i] /= l; p[i+1] /= l; p[i+2] /= l; p[i+3] /= l;\n        }\n        \n        //side is M'(1,0,0,1) - M'(-1,0,0,1) and they lie on the planes\n        const r3 = mi[3] + mi[15];\n        const r0 = (mi[0]  + mi[12 ])/r3;\n        const r1 = (mi[1]  + mi[13 ])/r3;\n        const r2 = (mi[2]  + mi[14 ])/r3;\n\n        const l3 = -mi[3] + mi[15];\n        const l0 = (-mi[0]  + mi[12 ])/l3 - r0;\n        const l1 = (-mi[1]  + mi[13 ])/l3 - r1;\n        const l2 = (-mi[2]  + mi[14 ])/l3 - r2;\n\n        const side = Math.sqrt(l0*l0 + l1*l1 + l2*l2);\n\n        //center of the scene is M'*(0, 0, 0, 1)\n        const c0 = mi[12]/mi[15] - t.viewpoint[0];\n        const c1 = mi[13]/mi[15] - t.viewpoint[1];\n        const c2 = mi[14]/mi[15] - t.viewpoint[2];\n        const dist = Math.sqrt(c0*c0 + c1*c1 + c2*c2);\n\n        const resolution = (2*side/dist)/ t.viewport[2];\n        t.currentResolution == resolution ? t.sameResolution = true : t.sameResolution = false;\n        t.currentResolution = resolution;\n    },\n\n    traverse : function (mesh, cache) {\n        let t = this;\n        t.mesh = mesh;\n//        if(Debug.extract == true)\n //           return;\n\n        if(!mesh.isReady) return;\n    \n        const n = mesh.nodesCount;\n        t.visited  = new Uint8Array(n);\n        t.blocked  = new Uint8Array(n);\n        t.selected = new Uint8Array(n);\n\n        t.frame = cache.frame;\n\n        t.instance_errors = new Float32Array(n);\n\n        if(t.frame > mesh.frame) { //clean the errors.\n            mesh.errors = new Float32Array(n); \n            mesh.frame = t.frame;\n        }\n\n        t.visitQueue = new _PriorityQueue_js__WEBPACK_IMPORTED_MODULE_1__.PriorityQueue(n);\n        for(var i = 0; i < mesh.nroots; i++)\n            t.insertNode(i);\n        \n        t.currentError = cache.currentError;\n        t.drawSize = 0;\n        t.nblocked = 0;\n\n        var requested = 0;\n        while(t.visitQueue.size && t.nblocked < t.maxBlocked) {\n            var error = t.visitQueue.error[0];\n            var id = t.visitQueue.pop();\n\n            //if not loaded and the queue is not full add to the candidates.\n            if (mesh.status[id] == 0 && requested < cache.maxPending) {\n                cache.candidates.push({id: id, mesh:mesh, frame:t.frame, error:error});\n                requested++;\n            }\n            /* we don't want to stop as soon as a node is not availabe, because the nodes are sorted by error, \n               this could cause a large drop in quality elsewere.\n               we still need to mark all children as blocked, to prevent including them in the cut of the dag. */\n            var blocked = t.blocked[id] || !t.expandNode(id, error);\n            if (blocked)\n                t.nblocked++;\n            else {\n                t.selected[id] = 1;\n                //cache.realError = Math.min(error, cache.realError);\n            }\n            t.insertChildren(id, blocked);\n        }\n\n        //update remaining errors in the cache\n        if(cache.nodes.has(mesh)) {\n            for(let id of cache.nodes.get(mesh)) {\n                let error = t.nodeError(id);\n                if(t.instance_errors[id] == 0) {\n                    t.instance_errors[i] = error;\n                    mesh.errors[id] = Math.max(mesh.errors[id], error);\n                }\n            }\n        }\n\n        t.mesh = null;\n        return t.instance_errors;\n    },\n\n    insertNode: function (node) {\n        let t = this;\n        t.visited[node] = 1;\n\n        const error = t.nodeError(node);\n\n        t.instance_errors[node] = error;\n        t.mesh.errors[node] = Math.max(error, t.mesh.errors[node]);\n        t.mesh.frames[node] = t.frame;\n\n//        if(node > 0 && error < t.currentError) return;  //2% speed TODO check if needed\n\n        t.visitQueue.push(node, error);\n    },\n\n    insertChildren : function (node, block) {\n        let t = this;\n        for(let i = t.mesh.nfirstpatch[node]; i < t.mesh.nfirstpatch[node+1]; ++i) {\n            const child = t.mesh.patches[i*3];\n            if (child == t.mesh.sink) return;\n            if (block) t.blocked[child] = 1;\n            if (!t.visited[child])\n                t.insertNode(child);\n        }\n    },\n\n    expandNode : function (node, error) {\n        let t = this;\n        if(node > 0 && error < t.currentError) {\n//\t\t\tconsole.log(\"Reached error\", error, t.currentError);\n            return false;\n        }\n\n        if(t.drawSize > t.drawBudget) {\n//\t\t\tconsole.log(\"Reached drawsize\", t.drawSize, t.drawBudget);\n            return false;\n        }\n\n        if(t.mesh.status[node] != 1) { //not ready\n//\t\t\tconsole.log(\"Node \" + node + \" still not loaded (cache?)\");\n            return false;\n        }\n\n        const sp = t.mesh.nspheres;\n        const off = node*5;\n        if(t.isVisible(sp[off], sp[off+1], sp[off+2], sp[off+3])) //expanded radius\n            t.drawSize += t.mesh.nvertices[node]*0.8;\n            //we are adding half of the new faces. (but we are using the vertices so *2)\n\n        return true;\n    },\n\n    nodeError : function (n, tight) {\n        let t = this;\n        const spheres = t.mesh.nspheres;\n        const b = t.viewpoint;\n        const off = n*5;\n        const cx = spheres[off+0];\n        const cy = spheres[off+1];\n        const cz = spheres[off+2];\n        let r  = spheres[off+3];\n        if(tight)\n            r = spheres[off+4];\n        const d0 = b[0] - cx;\n        const d1 = b[1] - cy;\n        const d2 = b[2] - cz;\n        let dist = Math.sqrt(d0*d0 + d1*d1 + d2*d2) - r;\n        if (dist < 0.1)\n            dist = 0.1;\n\n        //resolution is how long is a pixel at distance 1.\n        let error = t.mesh.nerrors[n]/(t.currentResolution*dist); //in pixels\n\n        //causes flickering due to things popping in and out of visibility, causes a huge resorting.\n        /*if (!t.isVisible(cx, cy, cz, spheres[off+4]))\n            error /= 100.0; */\n\n        //more stable, at least it's continuous.\n        let d = t.distance(cx, cy, cz, spheres[off+4]);\n        if(d < -r) {\n            error /= 101.0;\n        } else if(d < 0) {\n            error /= 1 -( d/r)*100.0\n        } \n        return error;\n    },\n\n    distance: function(x, y, z, r) {\n        const p = this.planes;\n        let min_distance = 1e20;\n        for (let i = 0; i < 24; i +=4) {\n            let d = p[i]*x + p[i+1]*y + p[i+2]*z + p[i+3] + r;\n            if(d < min_distance)\n                min_distance = d;\n        }\n        return min_distance;\n    },\n\n    isVisible : function (x, y, z, r) {\n        const p = this.planes;\n        for (let i = 0; i < 24; i +=4) {\n            if(p[i]*x + p[i+1]*y + p[i+2]*z + p[i+3] + r < 0) //plane is ax+by+cz+d = 0; \n                return false;\n        }\n        return true;\n    }\n}; \n\n\n\n\n//# sourceURL=webpack://Nexus3D/./src/Traversal.js?\n}");

/***/ }),

/***/ "three":
/*!**************************************************************************************!*\
  !*** external {"commonjs":"three","commonjs2":"three","amd":"three","root":"THREE"} ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/Nexus3D.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});